#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative "lib/cli_helpers"
require_relative "../config/environment"
require "optparse"
require "pp"

USAGE = "usage: mb-select sid:<surface_id> <index>".freeze

options = {
  raw: false
}
force_recording_mbid = nil

OptionParser.new do |opts|
  opts.banner = USAGE

  opts.on("--raw", "Print raw MusicBrainz search results") do
    options[:raw] = true
  end

  opts.on("--force-recording MBID", "Use an explicit recording MBID") do |mbid|
    force_recording_mbid = mbid
  end
end.parse!

surface_id = parse_surface_id!(ARGV.find { |arg| arg.start_with?("sid:") })

surface = RecordingSurface.find(surface_id)

puts "\n== RecordingSurface =="
pp(
  artist: surface.artist_name,
  recording: surface.track_name,
  release: surface.album_name
)

results = if force_recording_mbid
  [Clients::Musicbrainz.new.fetch_recording(force_recording_mbid)]
else
  Musicbrainz::RecordingSearch.call(
    artist: surface.artist_name,
    recording: surface.track_name,
    release: surface.album_name
  )
end

if options[:raw]
  puts "\n== Raw MusicBrainz Results =="
  pp results
  exit 0
end

candidates = Musicbrainz::ReleaseCandidateExtractor.call(results)

surface.update!(
  release_candidates: candidates.map(&:to_h),
  chosen_release_candidate_index: nil
)

puts "\n== Release Candidates (#{candidates.size}) =="
candidates.each_with_index do |c, idx|
  puts "\n[#{idx}]"
  pp c.to_h
end
